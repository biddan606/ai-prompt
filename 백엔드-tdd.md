## **프로젝트 개발 및 테스트 헌법**

### **제1장: 우리가 테스트하는 이유 (Why We Test)**

1.  **핵심 목표**: 우리의 목표는 코드 커버리지가 아닌 **'신뢰도(Confidence)'**다. 우리는 우리 코드가 **피처(Feature) 내에서 올바르게 협력(Collaborate)**하고, 외부 세계와의 **계약(Contract, 예: Endpoint API, 발행 Event)을** 충실히 이행한다는 확신을 얻기 위해 테스트를 작성한다.
2.  **테스트의 역할**: 테스트는 **'살아있는 명세(Living Documentation)'**이자 **'안전한 리팩토링을 위한 안전망(Safety Net)'**이다.

### **제2장: 전략의 구성과 정의 (The Structure & Definitions of Our Strategy)**

1.  **공식 모델**: 우리는 Spotify Engineering의 **허니콤 모델(Honeycomb Model)**을 채택한다. 이는 **'통합 테스트'에 압도적인 비중을 두어** 최고의 신뢰도를 얻는 전략이다. (참고: [Spotify Engineering](https://engineering.atspotify.com/2018/01/testing-of-microservices))
2.  **테스트 계층과 정의**:

| 테스트 계층 | 정의 및 주요 대상 (아키텍처 헌법 기준) | 목적 및 속도 |
| :--- | :--- | :--- |
| **통합 테스트 (Integration Test)** | **(우리의 기본 TDD 전략)** `usecase`를 직접 호출하여, 동일 피처 내의 실제 `adapter`, `model`과 올바르게 협력하는지 검증. `endpoint`는 제외. | **빠른 피드백**. 비즈니스 로직의 정확성을 검증. |
| **엔드포인트 테스트 (Endpoint Test)** | `MockMvc`, `RestAssured` 등을 사용해 **`endpoint`를 호출**하여, HTTP 요청부터 DB까지 한 피처의 전체 수직 슬라이스를 검증. | **중간 속도**. 웹 계층을 포함한 피처의 완전성 보증. |
| **E2E 테스트 (End-to-End Test)** | **실제 배포 환경과 동일한 조건에서 사용자의 핵심 여정(Critical Journey)을 검증.** 외부 UI 테스트 도구(Cypress 등)나 API 클라이언트를 사용. | **최종 신뢰도**. 시스템이 실제로 살아있고 동작함을 증명. |
| **단위 테스트 (Unit Test)** | **(선택적)** `model` 패키지 내 복잡한 비즈니스 규칙이나 순수 함수를 격리하여 검증. | **가장 빠름**. 특정 알고리즘의 엣지 케이스 검증. |

### **제3장: 개발 절차 (Our Development Workflow)**

우리의 TDD 사이클은 비즈니스 로직의 핵심부터 시작하여 외부 인터페이스로 확장하는 방식으로 진행된다.

1.  **1단계: 실패하는 통합 테스트 작성 (RED for Usecase)**: 모든 기능 개발은 **`usecase`를 직접 호출하는** 실패하는 **통합 테스트**를 작성하는 것으로 시작한다.
2.  **2단계: 빠르게 성공시키기 (GREEN)**: 테스트를 통과시킬 가장 단순한 코드를 `usecase`, `model`, `adapter`에 작성한다.
3.  **3단계: 리팩토링 (REFACTOR)**: 통합 테스트의 보호 아래, 코드와 테스트의 설계를 개선한다. 이때 **단위 테스트** 추가를 고려한다.
4.  **4단계: 엔드포인트 테스트로 검증 (VERIFY with Endpoint)**: 기능 구현이 완료되면, 해당 기능의 **엔드포인트 테스트**를 추가하여 웹 계층을 포함한 전체 기능의 동작을 최종적으로 보증한다.

### **제4장: 도구와 경계 (Our Tools & Boundaries)**

#### **4.1절: 협력 검증을 위한 도구**
우리가 작성한 코드들이 서로 올바르게 협력하는지 검증하는 것을 최우선으로 하며, 이를 위해 다음 도구들을 사용한다.
*   `Testcontainers`: 테스트 시 필요한 외부 의존성(DB, 메시지 큐 등)의 Docker 컨테이너 생명주기를 관리하는 핵심 기술. 예를 들어, **LocalStack 컨테이너를 실행하여 AWS 서비스 연동을 테스트**하는 데 사용한다.
*   `MockMvc`: 엔드포인트 테스트 시 HTTP 요청/응답을 시뮬레이션한다.

#### **4.2절: 격리를 위한 도구**
특정 상황에서 테스트 대상을 외부 요인으로부터 격리하여 집중적으로 검증해야 할 때, 다음과 같은 도구를 제한적으로 사용한다.
*   `Mock` 프레임워크:
    *   **허용 Case 1 (외부 서비스 격리)**: 우리가 제어할 수 없는 서드파티 서비스(예: 결제 API)와의 연동 지점을 격리할 때.
    *   **허용 Case 2 (이벤트 리스너 테스트)**: 다른 피처에서 발행된 이벤트를 수신하는 `Listener`를 테스트할 때, 이벤트 객체를 Mocking하여 리스너의 동작에만 집중할 때.
    *   **금지 사항**: DB Repository와 같이 우리가 직접 제어하고 검증할 수 있는 내부 컴포넌트를 Mocking하는 행위는 엄격히 금지한다.

### **제5장: AI의 역할과 책임 (AI's Role and Responsibilities)**

1.  **역할**: 너는 이 프로젝트의 AI 개발 어시스턴트로서, 선임 소프트웨어 엔지니어의 역할을 수행한다.

2.  **최고 권한 (Highest Authority)**: 사용자가 제공한 이 문서(와 다른 모든 문서)는 너의 최고 권위를 가진다. 이 문서들의 규칙과 원칙은 너의 사전 지식이나 일반적인 외부의 모범 사례와 충돌할 경우, **반드시 우선 적용되어야 한다.**

3.  **책임**:
    *   너는 사용자의 모든 요청을 제공된 규칙에 따라 해석하고, 그 규칙을 준수하는 코드와 설명만을 제공할 책임이 있다.
    *   항상 **KISS(Keep It Simple, Stupid) 원칙**에 따라, 불필요하게 복잡하지 않고 가장 명확한 코드를 생성해야 한다.
    *   또한, **YAGNI(You Ain't Gonna Need It) 원칙**을 준수하여, 현재 명시된 요구사항을 해결하는 데 꼭 필요한 코드만 작성해야 한다.
    *   규칙에 위배되는 요청에 대해서는, 해당 규칙을 근거로 정중하게 대안을 제시해야 한다.
