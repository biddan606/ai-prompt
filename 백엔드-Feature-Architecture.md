## 프로젝트 아키텍처 헌법 (The Project Architecture Constitution)

**버전: 4.0 (최종 완성판)**

### 제1장: 기본 철학

1.  **아키텍처 명칭**: 본 프로젝트는 **Event-Driven Feature Architecture**를 따른다. 이 아키텍처는 비즈니스 **피처(Feature)** 단위로 코드를 구성한다.
2.  **핵심 목표**: 모든 코드는 **높은 응집도(High Cohesion)**와 **낮은 결합도(Low Coupling)**를 지향한다. 각 기능은 독립적으로 존재하며, 기능 간의 소통은 오직 **이벤트(Event)**를 통해 이루어진다.
3.  **최고 원칙**: 이 문서는 프로젝트의 **유일한 진실 공급원(Single Source of Truth)**이다. 모든 코드(사람 또는 AI가 작성한)는 반드시 이 헌법을 준수해야 한다.

### 제2장: 핵심 개념 정의

이 아키텍처는 하나의 잘 조직된 **회사**와 같습니다. 이 회사의 운영 방식을 이해하기 위해 다음 세 가지 핵심 개념을 명확히 정의합니다.

1.  **피처 (Feature) - 전문 부서**:
    *   **정의**: `order`(주문 관리부), `user`(인사 관리부)와 같이, **회사의 특정 비즈니스 기능을 전담하는 독립적인 부서**입니다.
    *   **역할**: 각 부서는 자신의 책임(예: 주문 처리)을 완수하는 데 필요한 모든 자원(인터페이스, 로직, 데이터 등)을 내부에 갖추고 있습니다. 이것이 바로 **기능의 수직적 슬라이스(Vertical Slice)**입니다.
    *   **비유**: 회사의 **'부서(Department)'**. (예: 영업부, 회계부)

2.  **유스케이스 (Use Case) - 부서의 업무 프로세스**:
    *   **정의**: `PlaceOrder`(주문 접수), `CancelOrder`(주문 취소)와 같이, **부서가 수행하는 구체적인 단일 업무 프로세스**입니다.
    *   **역할**: `usecase` 디렉토리 내의 클래스로 구현되며, 하나의 부서(피처)는 여러 개의 업무 프로세스(유스케이스)를 가집니다.
    *   **비유**: 부서 내의 구체적인 **'업무(Task)'**. (예: 영업부의 '견적서 발행' 업무)

3.  **도메인 모델 (Domain Model) - 업무 양식 및 데이터**:
    *   **정의**: `Order` Entity, `User` Entity와 같이, **업무를 처리하는 데 사용되는 공식적인 양식, 데이터 구조, 그리고 규칙**입니다.
    *   **역할**: 유스케이스가 비즈니스 로직을 수행하기 위해 사용하는 핵심 자산입니다. `model` 디렉토리 내에 정의됩니다.
    *   **비유**: 업무 처리에 필수적인 **'공식 서류 양식(Official Form)'**. (예: '견적서' 양식 자체)

> **관계 요약**: 우리의 애플리케이션이라는 **회사**는 여러 전문 **부서(피처)**로 구성됩니다. 각 부서는 자신만의 **업무 프로세스(유스케이스)**를 가지고 있으며, 이 업무를 처리하기 위해 공식적인 **서류 양식(도메인 모델)**을 사용합니다. 부서 간의 협업은 직접적인 지시가 아닌, 공식적인 **메모(이벤트)**를 통해 이루어집니다.

### 제3장: 최상위 패키지 구조

애플리케이션의 최상위 패키지는 **비즈니스 피처(Feature) 패키지**와 이를 지원하는 **공통 모듈**로 구성된다.

```
src/main/java/com/myproject
├── order       // '주문 관리부' (비즈니스 피처 패키지)
├── user        // '인사 관리부' (비즈니스 피처 패키지)
├── config      // 회사의 기반 시설 및 전사적 규칙 (기술 기반 설정)
└── shared      // 모든 부서가 사용하는 공용 자원 (공통 협약)
```

### 제4장: `config` 패키지 - 기술 기반 및 전역 설정

1.  **책임**: `config` 패키지는 특정 비즈니스 피처에 속하지 않는, 애플리케이션 전반의 기술적인 설정과 횡단 관심사를 책임진다.
2.  **구성 요소**: `@Configuration` 클래스, 보안(`auth`), 예외 처리(`exception`), 웹(`web`) 관련 전역 컴포넌트.
3.  **의존성 규칙**: `config`는 비즈니스 피처나 `shared`에 의존할 수 있다. 하지만 **비즈니스 피처와 `shared`는 절대 `config`를 알 수 없다.**

### 제5장: 비즈니스 피처(Feature) 패키지

1.  **정의**: `order`, `user`와 같이, 애플리케이션의 핵심 비즈니스 기능을 담당하는 최상위 패키지를 '피처 패키지'라 칭한다.
2.  **피처 패키지 내부의 엄격한 템플릿**: 모든 피처 패키지는 아래 5개의 하위 패키지를 **반드시** 가져야 한다.
    ```
    └── order
        ├── endpoint    // 부서의 대외 창구 (통신 진입점)
        ├── adapter     // 외부 시스템 연동 전담팀 (연동 구현체)
        ├── usecase     // 핵심 업무 프로세스 (유스케이스)
        ├── event       // 부서 간 공식 메모 (이벤트)
        └── model       // 공식 업무 양식 및 데이터 (도메인 모델)
    ```
    *   **`endpoint`**: 외부의 요청(`Request`)을 받아 적절한 **유스케이스**를 위한 `Command`를 생성하고, `Result`를 받아 외부로 응답(`Response`)하는 책임.
    *   **`adapter`**: `model`에 정의된 `Repository` 인터페이스의 **구현체**가 위치.
    *   **`usecase`**: 각 클래스는 단일 비즈니스 시나리오(유스케이스)를 책임지며, `Command`, `Result`, `execute()` 패턴을 **강력히 권장**한다.
    *   **`event`**: 유스케이스 실행 후 발생하는 상태 변경 결과를 알리는 이벤트 객체.
    *   **`model`**: `@Entity`와 `@Repository` **인터페이스**를 정의. **절대 구현체를 포함하지 않는다.**

### 제6장: `shared` 패키지 - 공통 협약

1.  **책임**: 둘 이상의 **비즈니스 피처**에서 **의도적으로 공유**되는 코드를 관리한다.
2.  **생성 규칙**: **절대 처음부터 `shared`에 코드를 만들지 않는다.** 명백한 중복이 발견되었을 때 리팩토링을 통해 이동시킨다 (Yagni 원칙).
3.  **구성 요소**: `ApiResponse`, `BaseEntity` 등.

### 제7장: 상호작용 법칙

1.  **피처 간 통신**: 피처 패키지(부서) 간의 직접적인 메서드 호출은 **엄격히 금지**한다. 통신이 필요한 경우, 한 피처가 `event`(메모)를 발행하고 다른 피처의 `listener`가 이를 수신하는 방식만을 허용한다.

### 제8장: 아키텍처 적용 원칙

1.  **피처-특화 예외 처리**: 피처 고유의 예외는 해당 피처 내 `model/exception`에 정의한다.
2.  **데이터 객체(DTO) 관리 헌장**:
    *   **제1조 (사용 원칙)**:
        *   **외부 경계 (의무)**: `endpoint`, `adapter`에서는 DTO 사용을 의무화한다.
        *   **내부 흐름 (강력 권장)**: **의미 있는 개념으로 값을 묶거나, 파라미터가 3개를 초과하는 경우 DTO 사용을 강력히 권장**한다.
    *   **제2조 (종류와 위치)**:
        *   **Endpoint DTOs**: `endpoint` 패키지 내부에 위치한다.
        *   **Use Case DTOs (`Command`/`Result`)**: `usecase` 디렉토리의 유스케이스 클래스 내 중첩 클래스를 기본으로 한다.
        *   **Adapter DTOs**: 해당 `adapter` 패키지 내부에 위치한다.
    *   **제3조 (공용 DTO 관리)**: 피처 내 공용은 해당 계층 내 `dto` 패키지에, 피처 간 공용은 최상위 `shared/dto` 패키지를 사용한다.
3.  **`Command` 패턴의 정의**: `usecase`에서 사용하는 `Command`는 **'Use Case Command Pattern'**으로, 동기적으로 처리되어 반드시 `Result`를 반환한다.

### 제9장: AI 협업 가이드 (Instructions for AI)

AI 개발 지원 시스템은 이 헌법의 모든 조항, 특히 **제2장의 핵심 개념**을 숙지하고 다음 지침을 반드시 준수해야 한다.

*   **요청 형식**: `"헌법 제5장에 따라, '주문 취소' 유스케이스를 `order` 피처(주문 관리부)에 추가해줘. `usecase` 디렉토리에 `CancelOrder.java` 파일을 생성해야 해."`
*   **파일 위치**: 새로운 클래스를 생성할 때, 헌법에 명시된 정확한 패키지 위치에 생성해야 한다.
*   **원칙 준수**: 모든 코드 생성 시 헌법 제8장의 원칙들을 준수해야 한다.
*   **금지 사항**: 헌법에 위배되는 코드(예: 피처 간 직접 호출, 잘못된 의존성)를 생성해서는 안 된다.

**이 문서는 살아있는 문서이며, 팀의 합의에 따라 개정될 수 있다. 하지만 개정 전까지 모든 구성원(AI 포함)은 이 헌법을 따른다.**
